"use strict";
/**
 * @license
 * Copyright 2019 Ludan Stoecklé
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConjugation = exports.getVerbInfo = exports.getIngPart = exports.mergeVerbsData = void 0;
const tenses = [
    // SIMPLE
    'SIMPLE_PAST',
    'PAST',
    'SIMPLE_PRESENT',
    'PRESENT',
    'SIMPLE_FUTURE',
    'FUTURE',
    // PROGRESSIVE
    'PROGRESSIVE_PAST',
    'PROGRESSIVE_PRESENT',
    'PROGRESSIVE_FUTURE',
    // PERFECT
    'PERFECT_PAST',
    'PERFECT_PRESENT',
    'PERFECT_FUTURE',
    // PERFECT PROGRESSIVE
    'PERFECT_PROGRESSIVE_PAST',
    'PERFECT_PROGRESSIVE_PRESENT',
    'PERFECT_PROGRESSIVE_FUTURE',
    // PARTICIPLE
    'PARTICIPLE_PRESENT',
    'PARTICIPLE_PAST',
];
const modals = ['can', 'could', 'may', 'might', 'must', 'shall', 'should', 'will', 'would', 'ought'];
// helpers
function mergeVerbsData(irregularsInfo, gerundsInfo) {
    const res = {};
    // gerunds
    if (gerundsInfo) {
        const gerundKeys = Object.keys(gerundsInfo);
        for (const gerundKey of gerundKeys) {
            const gerundVal = gerundsInfo[gerundKey];
            res[gerundKey] = [null, null, gerundVal];
        }
    }
    // irregulars
    if (irregularsInfo) {
        const irregularKeys = Object.keys(irregularsInfo);
        for (const irregularKey of irregularKeys) {
            const irregularVal = irregularsInfo[irregularKey];
            if (!res[irregularKey]) {
                res[irregularKey] = [irregularVal[0][0], irregularVal[0][1], null];
            }
            else {
                res[irregularKey] = [irregularVal[0][0], irregularVal[0][1], res[irregularKey][2]];
            }
        }
    }
    return res;
}
exports.mergeVerbsData = mergeVerbsData;
function getIrregularHelper(verbsInfo, verb, index) {
    const verbInfo = getVerbInfo(verbsInfo, verb);
    if (verbInfo && verbInfo.length != 0) {
        return verbInfo[index];
    }
    else {
        return null;
    }
}
function getCommonEdPart(verb) {
    if (verb.endsWith('ie') || verb.endsWith('ee')) {
        return verb + 'd';
    }
    else if (yWithVowel(verb)) {
        // vowel + y: play -> played
        return verb + 'ed';
    }
    else if (verb.endsWith('y')) {
        // no vowel + y: cry -> cried
        return verb.substring(0, verb.length - 1) + 'ied';
    }
    else if (verb.endsWith('e')) {
        return verb + 'd';
    }
    else {
        return verb + 'ed';
    }
}
function getPastPart(verbsInfo, verb) {
    if (verb === 'be') {
        return 'been';
    }
    else {
        const irregular = getIrregularHelper(verbsInfo, verb, 1);
        if (irregular) {
            return irregular;
        }
        else {
            return getCommonEdPart(verb);
        }
    }
}
function getPreteritPart(verbsInfo, verb, person) {
    let irregular;
    if (verb === 'be') {
        if (person === 0 || person === 2) {
            return 'was';
        }
        else {
            return 'were';
        }
    }
    else if ((irregular = getIrregularHelper(verbsInfo, verb, 0))) {
        return irregular;
    }
    else {
        return getCommonEdPart(verb);
    }
}
function getIngPart(verbsInfo, verb) {
    const consonants = 'bcdfghjklmnpqrstvxzw';
    const irregular = getIrregularHelper(verbsInfo, verb, 2);
    if (irregular) {
        return irregular;
    }
    else if (verb.match(new RegExp(`[${consonants}]e$`, 'g')) && verb != 'be' && verb != 'singe') {
        // If  the  infinitive  ends  with  a  consonant followed by an –e,
        // you have to take off the –e to form your present participle.
        // this is not in the english-verbs-gerunds list
        // hum and unless it is 'to be'! which becomes being, not bing.
        return verb.substring(0, verb.length - 1) + 'ing';
    }
    else {
        return verb + 'ing';
    }
}
exports.getIngPart = getIngPart;
/* does not throw an exception:
most verb conjugation is rule based, thus not finding it in the resource is not a problem */
function getVerbInfo(verbsInfo, verb) {
    return verbsInfo ? verbsInfo[verb] : null;
}
exports.getVerbInfo = getVerbInfo;
// 1 per tense
function getSimplePast(verbsInfo, verb, person) {
    return getPreteritPart(verbsInfo, verb, person);
}
function yWithVowel(verb) {
    return verb.match(/[aeiouy]y$/) !== null;
}
function getSimplePresentHeShe(verb) {
    if (modals.indexOf(verb) > -1) {
        return verb;
    }
    else if (verb === 'have') {
        return 'has';
    }
    else if (verb === 'be') {
        return 'is';
    }
    else if (verb === 'do') {
        return 'does';
    }
    else if (verb === 'go') {
        return 'goes';
    }
    else if (yWithVowel(verb)) {
        // vowel + y: play -> plays
        return verb + 's';
    }
    else if (verb.endsWith('y')) {
        // no vowel + y: fly -> flies
        return verb.substring(0, verb.length - 1) + 'ies';
    }
    else if (verb.endsWith('ss') || verb.endsWith('x') || verb.endsWith('sh') || verb.endsWith('ch')) {
        return verb + 'es';
    }
    else {
        // default
        return verb + 's';
    }
}
function getSimplePresent(verb, person) {
    if (person != 2) {
        if (verb === 'be') {
            if (person === 0) {
                return 'am';
            }
            else {
                return 'are';
            }
        }
        else {
            return verb;
        }
    }
    else {
        return getSimplePresentHeShe(verb);
    }
}
function getSimpleFuture(verb, person, isGoingTo, negative) {
    if (isGoingTo) {
        return getSimplePresent('be', person) + ' ' + getNegative(negative) + 'going to ' + verb;
    }
    else {
        return 'will ' + getNegative(negative) + verb;
    }
}
function getNegative(negative) {
    return negative ? 'not ' : '';
}
function getProgressivePast(verbsInfo, verb, person, negative) {
    return getPreteritPart(verbsInfo, 'be', person) + ' ' + getNegative(negative) + getIngPart(verbsInfo, verb);
}
function getProgressivePresent(verbsInfo, verb, person, negative) {
    return getSimplePresent('be', person) + ' ' + getNegative(negative) + getIngPart(verbsInfo, verb);
}
function getProgressiveFuture(verbsInfo, verb, negative) {
    return 'will ' + getNegative(negative) + 'be ' + getIngPart(verbsInfo, verb);
}
function getPerfectPast(verbsInfo, verb, negative) {
    return 'had ' + getNegative(negative) + getPastPart(verbsInfo, verb);
}
function getPerfectPresent(verbsInfo, verb, person, negative) {
    return getSimplePresent('have', person) + ' ' + getNegative(negative) + getPastPart(verbsInfo, verb);
}
function getPerfectFuture(verbsInfo, verb, negative) {
    return 'will ' + getNegative(negative) + 'have ' + getPastPart(verbsInfo, verb);
}
function getPerfectProgressivePast(verbsInfo, verb, negative) {
    return 'had ' + getNegative(negative) + 'been ' + getIngPart(verbsInfo, verb);
}
function getPerfectProgressivePresent(verbsInfo, verb, person, negative) {
    return getSimplePresent('have', person) + ' ' + getNegative(negative) + 'been ' + getIngPart(verbsInfo, verb);
}
function getPerfectProgressiveFuture(verbsInfo, verb, negative) {
    return 'will ' + getNegative(negative) + 'have been ' + getIngPart(verbsInfo, verb);
}
function doContract(original) {
    const contractions = [
        // present
        ['does not', "doesn't"],
        ['do not', "don't"],
        ['is not', "isn't"],
        ['are not', "aren't"],
        ['has not', "hasn't"],
        ['have not', "haven't"],
        ['can not', "can't"],
        ['could not', "couldn't"],
        ['may not', "mayn't"],
        ['might not', "mightn't"],
        ['will not', "won't"],
        ['shall not', "shan't"],
        ['would not', "wouldn't"],
        ['should not', "shouldn't"],
        ['must not', "mustn't"],
        ['ought not', "oughtn't"],
        // past
        ['did not', "didn't"],
        ['was not', "wasn't"],
        ['were not', "weren't"],
        ['had not', "hadn't"],
    ];
    for (const contraction of contractions) {
        const replaced = original.replace(contraction[0], contraction[1]);
        if (replaced !== original) {
            // finding one in fine, then we stop
            return replaced;
        }
    }
    // istanbul ignore next
    return original;
}
function getConjugatedVerb(verbsInfo, verb, tense, person, isNegative, isHaveNoDo, isGoingTo) {
    switch (tense) {
        case 'PAST':
        case 'SIMPLE_PAST':
            if (isNegative) {
                if (verb === 'be' || verb === 'do' || modals.indexOf(verb) > -1 || isHaveNoDo) {
                    return getSimplePast(verbsInfo, verb, person) + ' not';
                }
                else {
                    // 'do ...' form
                    return getSimplePast(verbsInfo, 'do', person) + ' not ' + verb;
                }
            }
            else {
                return getSimplePast(verbsInfo, verb, person);
            }
        case 'PRESENT':
        case 'SIMPLE_PRESENT':
            if (isNegative) {
                if (verb === 'be' || verb === 'do' || modals.indexOf(verb) > -1 || isHaveNoDo) {
                    return getSimplePresent(verb, person) + ' not';
                }
                else {
                    // 'do ...' form
                    return getSimplePresent('do', person) + ' not ' + verb;
                }
            }
            else {
                return getSimplePresent(verb, person);
            }
        case 'FUTURE':
        case 'SIMPLE_FUTURE':
            return getSimpleFuture(verb, person, isGoingTo, isNegative);
        case 'PROGRESSIVE_PAST':
            return getProgressivePast(verbsInfo, verb, person, isNegative);
        case 'PROGRESSIVE_PRESENT':
            return getProgressivePresent(verbsInfo, verb, person, isNegative);
        case 'PROGRESSIVE_FUTURE':
            return getProgressiveFuture(verbsInfo, verb, isNegative);
        case 'PERFECT_PAST':
            return getPerfectPast(verbsInfo, verb, isNegative);
        case 'PERFECT_PRESENT':
            return getPerfectPresent(verbsInfo, verb, person, isNegative);
        case 'PERFECT_FUTURE':
            return getPerfectFuture(verbsInfo, verb, isNegative);
        case 'PERFECT_PROGRESSIVE_PAST':
            return getPerfectProgressivePast(verbsInfo, verb, isNegative);
        case 'PERFECT_PROGRESSIVE_PRESENT':
            return getPerfectProgressivePresent(verbsInfo, verb, person, isNegative);
        case 'PERFECT_PROGRESSIVE_FUTURE':
            return getPerfectProgressiveFuture(verbsInfo, verb, isNegative);
        case 'PARTICIPLE_PRESENT':
            return (isNegative ? 'not ' : '') + getIngPart(verbsInfo, verb);
        case 'PARTICIPLE_PAST':
            return (isNegative ? 'not ' : '') + getPastPart(verbsInfo, verb);
    }
}
function getConjugation(verbsInfo, verb, tense, person, extraParams) {
    if (!verb) {
        const err = new Error();
        err.name = 'TypeError';
        err.message = 'verb must not be null';
        throw err;
    }
    if (tenses.indexOf(tense) == -1) {
        const err = new Error();
        err.name = 'TypeError';
        err.message = `invalid tense: ${tense}`;
        throw err;
    }
    if ([0, 1, 2, 3, 4, 5].indexOf(person) === -1) {
        const err = new Error();
        err.name = 'TypeError';
        err.message = 'person must be 0 1 2 3 4 or 5';
        throw err;
    }
    const isGoingTo = extraParams && extraParams.GOING_TO ? true : false;
    const isNegative = extraParams && extraParams.NEGATIVE ? true : false;
    const isHaveNoDo = isNegative && verb === 'have' && extraParams.NO_DO ? true : false;
    const conjugated = getConjugatedVerb(verbsInfo, verb, tense, person, isNegative, isHaveNoDo, isGoingTo);
    if (isNegative && (extraParams.CONTRACT || isHaveNoDo)) {
        // Note that in the form without the auxiliary verb DO, the verb HAVE is always contracted with the adverb not.
        return doContract(conjugated);
    }
    else {
        return conjugated;
    }
}
exports.getConjugation = getConjugation;
//# sourceMappingURL=index.js.map